(self.webpackChunkpos_base=self.webpackChunkpos_base||[]).push([[832],{7832:(e,t,n)=>{n.r(t),n.d(t,{combine:()=>d,createJSONStorage:()=>c,devtools:()=>a,persist:()=>v,redux:()=>r,subscribeWithSelector:()=>l});const r=(e,t)=>(n,r,o)=>(o.dispatch=t=>(n((n=>e(n,t)),!1,t),t),o.dispatchFromDevtools=!0,{dispatch:(...e)=>o.dispatch(...e),...t}),o=new Map,s=e=>{const t=o.get(e);return t?Object.fromEntries(Object.entries(t.stores).map((([e,t])=>[e,t.getState()]))):{}},a=(e,t={})=>(n,r,a)=>{const{enabled:l,anonymousActionType:d,store:c,...u}=t;let v;try{v=(null==l||l)&&window.__REDUX_DEVTOOLS_EXTENSION__}catch(e){}if(!v)return l&&console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension"),e(n,r,a);const{connection:p,...m}=((e,t,n)=>{if(void 0===e)return{type:"untracked",connection:t.connect(n)};const r=o.get(n.name);if(r)return{type:"tracked",store:e,...r};const s={connection:t.connect(n),stores:{}};return o.set(n.name,s),{type:"tracked",store:e,...s}})(c,v,u);let g=!0;a.setState=(e,t,o)=>{const i=n(e,t);if(!g)return i;const l=void 0===o?{type:d||"anonymous"}:"string"==typeof o?{type:o}:o;return void 0===c?(null==p||p.send(l,r()),i):(null==p||p.send({...l,type:`${c}/${l.type}`},{...s(u.name),[c]:a.getState()}),i)};const h=(...e)=>{const t=g;g=!1,n(...e),g=t},f=e(a.setState,r,a);if("untracked"===m.type?null==p||p.init(f):(m.stores[m.store]=a,null==p||p.init(Object.fromEntries(Object.entries(m.stores).map((([e,t])=>[e,e===m.store?f:t.getState()]))))),a.dispatchFromDevtools&&"function"==typeof a.dispatch){let e=!1;const t=a.dispatch;a.dispatch=(...n)=>{"__setState"!==n[0].type||e||(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),e=!0),t(...n)}}return p.subscribe((e=>{var t;switch(e.type){case"ACTION":return"string"!=typeof e.payload?void console.error("[zustand devtools middleware] Unsupported action format"):i(e.payload,(e=>{if("__setState"!==e.type)a.dispatchFromDevtools&&"function"==typeof a.dispatch&&a.dispatch(e);else{if(void 0===c)return void h(e.state);1!==Object.keys(e.state).length&&console.error('\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using \'store\' option in devtools(), the \'state\' should have only one key, which is a value of \'store\' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }\n                    ');const t=e.state[c];if(null==t)return;JSON.stringify(a.getState())!==JSON.stringify(t)&&h(t)}}));case"DISPATCH":switch(e.payload.type){case"RESET":return h(f),void 0===c?null==p?void 0:p.init(a.getState()):null==p?void 0:p.init(s(u.name));case"COMMIT":return void 0===c?void(null==p||p.init(a.getState())):null==p?void 0:p.init(s(u.name));case"ROLLBACK":return i(e.state,(e=>{if(void 0===c)return h(e),void(null==p||p.init(a.getState()));h(e[c]),null==p||p.init(s(u.name))}));case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return i(e.state,(e=>{void 0!==c?JSON.stringify(a.getState())!==JSON.stringify(e[c])&&h(e[c]):h(e)}));case"IMPORT_STATE":{const{nextLiftedState:n}=e.payload,r=null==(t=n.computedStates.slice(-1)[0])?void 0:t.state;if(!r)return;return h(void 0===c?r:r[c]),void(null==p||p.send(null,n))}case"PAUSE_RECORDING":return g=!g}return}})),f},i=(e,t)=>{let n;try{n=JSON.parse(e)}catch(e){console.error("[zustand devtools middleware] Could not parse the received json",e)}void 0!==n&&t(n)},l=e=>(t,n,r)=>{const o=r.subscribe;return r.subscribe=(e,t,n)=>{let s=e;if(t){const o=(null==n?void 0:n.equalityFn)||Object.is;let a=e(r.getState());s=n=>{const r=e(n);if(!o(a,r)){const e=a;t(a=r,e)}},(null==n?void 0:n.fireImmediately)&&t(a,a)}return o(s)},e(t,n,r)},d=(e,t)=>(...n)=>Object.assign({},e,t(...n));function c(e,t){let n;try{n=e()}catch(e){return}return{getItem:e=>{var r;const o=e=>null===e?null:JSON.parse(e,null==t?void 0:t.reviver),s=null!=(r=n.getItem(e))?r:null;return s instanceof Promise?s.then(o):o(s)},setItem:(e,r)=>n.setItem(e,JSON.stringify(r,null==t?void 0:t.replacer)),removeItem:e=>n.removeItem(e)}}const u=e=>t=>{try{const n=e(t);return n instanceof Promise?n:{then:e=>u(e)(n),catch(e){return this}}}catch(e){return{then(e){return this},catch:t=>u(t)(e)}}},v=(e,t)=>"getStorage"in t||"serialize"in t||"deserialize"in t?(console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),((e,t)=>(n,r,o)=>{let s={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:e=>e,version:0,merge:(e,t)=>({...t,...e}),...t},a=!1;const i=new Set,l=new Set;let d;try{d=s.getStorage()}catch(e){}if(!d)return e(((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),n(...e)}),r,o);const c=u(s.serialize),v=()=>{const e=s.partialize({...r()});let t;const n=c({state:e,version:s.version}).then((e=>d.setItem(s.name,e))).catch((e=>{t=e}));if(t)throw t;return n},p=o.setState;o.setState=(e,t)=>{p(e,t),v()};const m=e(((...e)=>{n(...e),v()}),r,o);let g;const h=()=>{var e;if(!d)return;a=!1,i.forEach((e=>e(r())));const t=(null==(e=s.onRehydrateStorage)?void 0:e.call(s,r()))||void 0;return u(d.getItem.bind(d))(s.name).then((e=>{if(e)return s.deserialize(e)})).then((e=>{if(e){if("number"!=typeof e.version||e.version===s.version)return e.state;if(s.migrate)return s.migrate(e.state,e.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}})).then((e=>{var t;return g=s.merge(e,null!=(t=r())?t:m),n(g,!0),v()})).then((()=>{null==t||t(g,void 0),a=!0,l.forEach((e=>e(g)))})).catch((e=>{null==t||t(void 0,e)}))};return o.persist={setOptions:e=>{s={...s,...e},e.getStorage&&(d=e.getStorage())},clearStorage:()=>{null==d||d.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>h(),hasHydrated:()=>a,onHydrate:e=>(i.add(e),()=>{i.delete(e)}),onFinishHydration:e=>(l.add(e),()=>{l.delete(e)})},h(),g||m})(e,t)):((e,t)=>(n,r,o)=>{let s={storage:c((()=>localStorage)),partialize:e=>e,version:0,merge:(e,t)=>({...t,...e}),...t},a=!1;const i=new Set,l=new Set;let d=s.storage;if(!d)return e(((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),n(...e)}),r,o);const v=()=>{const e=s.partialize({...r()});return d.setItem(s.name,{state:e,version:s.version})},p=o.setState;o.setState=(e,t)=>{p(e,t),v()};const m=e(((...e)=>{n(...e),v()}),r,o);let g;const h=()=>{var e,t;if(!d)return;a=!1,i.forEach((e=>{var t;return e(null!=(t=r())?t:m)}));const o=(null==(t=s.onRehydrateStorage)?void 0:t.call(s,null!=(e=r())?e:m))||void 0;return u(d.getItem.bind(d))(s.name).then((e=>{if(e){if("number"!=typeof e.version||e.version===s.version)return e.state;if(s.migrate)return s.migrate(e.state,e.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}})).then((e=>{var t;return g=s.merge(e,null!=(t=r())?t:m),n(g,!0),v()})).then((()=>{null==o||o(g,void 0),g=r(),a=!0,l.forEach((e=>e(g)))})).catch((e=>{null==o||o(void 0,e)}))};return o.persist={setOptions:e=>{s={...s,...e},e.storage&&(d=e.storage)},clearStorage:()=>{null==d||d.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>h(),hasHydrated:()=>a,onHydrate:e=>(i.add(e),()=>{i.delete(e)}),onFinishHydration:e=>(l.add(e),()=>{l.delete(e)})},s.skipHydration||h(),g||m})(e,t)}}]);